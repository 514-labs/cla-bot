import { createCipheriv, createDecipheriv, createHash, randomBytes } from "node:crypto"

function getEncryptionKey(): Buffer | null {
  const material = process.env.ENCRYPTION_KEY || process.env.SESSION_SECRET
  if (!material) return null
  return createHash("sha256").update(material).digest()
}

/**
 * Encrypt plaintext for at-rest storage using AES-256-GCM.
 * Returns a dot-delimited payload: iv.tag.ciphertext (all base64url).
 */
export function encryptSecret(plainText: string): string | null {
  const key = getEncryptionKey()
  if (!key) return null

  const iv = randomBytes(12)
  const cipher = createCipheriv("aes-256-gcm", key, iv)
  const encrypted = Buffer.concat([cipher.update(plainText, "utf8"), cipher.final()])
  const tag = cipher.getAuthTag()

  return `${iv.toString("base64url")}.${tag.toString("base64url")}.${encrypted.toString("base64url")}`
}

/**
 * Decrypt payload generated by encryptSecret.
 */
export function decryptSecret(payload: string): string | null {
  const key = getEncryptionKey()
  if (!key) return null

  const [ivB64, tagB64, encryptedB64] = payload.split(".")
  if (!ivB64 || !tagB64 || !encryptedB64) return null

  try {
    const iv = Buffer.from(ivB64, "base64url")
    const tag = Buffer.from(tagB64, "base64url")
    const encrypted = Buffer.from(encryptedB64, "base64url")

    const decipher = createDecipheriv("aes-256-gcm", key, iv)
    decipher.setAuthTag(tag)
    const decrypted = Buffer.concat([decipher.update(encrypted), decipher.final()])
    return decrypted.toString("utf8")
  } catch {
    return null
  }
}
